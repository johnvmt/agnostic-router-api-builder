{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/agnostic-router/src/Router.js","node_modules/url-pattern/lib/url-pattern.js","src/ApiRouter.js","src/Utils.js"],"names":["Router","this","useRoutes","methodRoutes","index","UrlPattern","require","prototype","route","queueNext","routeMatch","routeMatches","shift","request","params","handler","respond","_isRouter","method","queueEnd","arguments","length","path","_methodPathMatches","use","_validHandler","_addRouteToArray","_normalizePath","useFirst","Array","replace","pathNormalized","matches","self","forEach","match","push","array","prepend","unshift","module","exports","slice","root","factory","define","amd","P","astNodeContainsSegmentsForProvidedParams","astNodeToNames","astNodeToRegexString","baseAstNodeToRegexString","concatMap","defaultOptions","escapeForRegex","getParam","keysAndValuesToObject","newParser","regexGroupCount","stringConcatMap","stringify","string","f","i","results","concat","result","regex","RegExp","toString","exec","keys","values","key","object","value","isArray","Result","rest","Tagged","tag","parser","input","tagged","sequence","parsers","call","pick","indexes","apply","lazy","fn","cached","baseMany","end","stringResult","atLeastOneResultRequired","parserResult","many1","concatMany1Till","firstChoice","options","U","wildcard","wildcardChar","optional","optionalSegmentStartChar","pattern","optionalSegmentEndChar","name","segmentNameCharset","named","segmentNameStartChar","escapedChar","escapeChar","token","segmentValueCharset","astNode","node","nextIndexes","sideEffects","maxIndex","Error","arg1","arg2","groupCount","parsed","isRegex","ast","names","TypeError","url","groups","Object","AgnosticRouter","Utils","_sanitizeArgumentConfig","argumentConfigDirty","argumentConfigDefault","level","argumentConfigSanitized","objectMerge","source","toObject","apiConfig","callback","router","objectForEach","functionConfig","functionName","urlPattern","argumentsConfig","argumentsArray","functionCallback","pop","parsedFunctionArguments","parseArgs","requestArguments","argumentConfig","objectSet","urlPath","passArguments","toRouter","targetObject","next","parsedArgs","argumentRequestPath","objectIsset","objectGet","merged","argument","attrname","hasOwnProperty","objectFilter","filter","child","property","parent","objectFilterProperties","argsPassed","argsConfig","validArg","argConfig","arg","validate","requiredLeftEnough","minIndex","required","matched","argConfigMin","ctr","default"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var UrlPattern = require('url-pattern');\n\nfunction Router() {\n\tthis.useRoutes = [];\n\tthis.methodRoutes = {};\n\tthis.index = 0;\n\tthis.UrlPattern = UrlPattern;\n}\n\nRouter.prototype.route = function() {\n\t// takes method, path, [request], respond\n\tif(arguments.length == 3) {\n\t\tvar request = {};\n\t\tvar respond = arguments[2];\n\t}\n\telse if(arguments.length >= 4) {\n\t\tvar request = arguments[2];\n\t\tif(typeof request !== \"object\" || !request)\n\t\t\trequest = {};\n\t\tvar respond = arguments[3];\n\t}\n\trequest.method = arguments[0];\n\n\tvar path = arguments[1];\n\tif(typeof request.path === 'undefined') // only overwrite path if doesn't already exist (carries through all routers)\n\t\trequest.path = path;\n\n\tvar queueEnd = arguments[4];\n\n\tvar routeMatches = this._methodPathMatches(request.method, path);\n\tqueueNext();\n\n\tfunction queueNext() {\n\t\tvar routeMatch = routeMatches.shift();\n\t\tif(typeof routeMatch !== \"undefined\") {\n\t\t\trequest.params = routeMatch.params; // overwrite params on each new route match\n\t\t\tif(typeof routeMatch.handler === \"function\")\n\t\t\t\trouteMatch.handler(request, respond, queueNext);\n\t\t\telse if(Router._isRouter(routeMatch.handler))\n\t\t\t\trouteMatch.handler.route(request.method, '/' + request.params['_'], request, respond, queueNext); // cycle through the router, then rejoin the queue\n\t\t\telse // route handler isn't a function or a router\n\t\t\t\tqueueNext();\n\t\t}\n\t\telse if(typeof queueEnd === 'function') // reached the end of the queue\n\t\t\tqueueEnd();\n\t}\n\n};\n\nRouter.prototype.use = function() {\n\t// [path], handler\n\tvar path = (typeof arguments[0] === 'string') ? arguments[0] : '';\n\tvar handler = Router._validHandler(arguments[0]) ? arguments[0] : arguments[1];\n\n\treturn this._addRouteToArray(this.useRoutes, Router._normalizePath(path), handler);\n};\n\nRouter.prototype.useFirst = function() {\n\t// [path], handler\n\tvar path = (typeof arguments[0] === 'string') ? arguments[0] : '';\n\tvar handler = Router._validHandler(arguments[0]) ? arguments[0] : arguments[1];\n\n\treturn this._addRouteToArray(this.useRoutes, Router._normalizePath(path), handler, true);\n};\n\nRouter.prototype.method = function(method, path, handler) {\n\tif(!(this.methodRoutes[method] instanceof Array)) // create the stack if it doesn't exist\n\t\tthis.methodRoutes[method] = [];\n\treturn this._addRouteToArray(this.methodRoutes[method], Router._normalizePath(path), handler);\n};\n\n/* Private functions */\nRouter._validHandler = function(handler) {\n\treturn (typeof handler === 'function' || Router._isRouter(handler)); // must be function or router\n};\n\nRouter._isRouter = function(handler) {\n\treturn (typeof handler === 'object' && typeof handler.route === 'function'); // must be function or router\n};\n\nRouter._normalizePath = function(path) {\n\treturn path.replace(/\\/$/, ''); // strip trailing slash\n};\n\nRouter.prototype._methodPathMatches = function(method, path) {\n\tvar pathNormalized = Router._normalizePath(path);\n\tvar matches = [];\n\tvar self = this;\n\n\tself.useRoutes.forEach(function(route) {\n\t\tvar routeMatch = (new UrlPattern(route.path + '(/*)')).match(pathNormalized);\n\t\t//console.log(\"RU\", routeMatch, route.path, pathNormalized);\n\t\tif(routeMatch !== null)\n\t\t\tmatches.push({path: route.path, handler: route.handler, params: routeMatch});\n\t});\n\n\tif(self.methodRoutes[method] instanceof Array) {\n\t\tself.methodRoutes[method].forEach(function(route) {\n\t\t\tvar routeMatch = (new UrlPattern(route.path)).match(pathNormalized);\n\t\t\t//console.log(\"RM\", route.path, pathNormalized, routeMatch);\n\t\t\tif(routeMatch !== null)\n\t\t\t\tmatches.push({path: route.path, handler: route.handler, params: routeMatch});\n\t\t});\n\t}\n\n\treturn matches;\n};\n\nRouter.prototype._addRouteToArray = function(array, path, handler, prepend) {\n\tvar route = {path: path, handler: handler};\n\tif(typeof prepend === 'boolean') //prepend\n\t\tarray.unshift(route);\n\telse //append\n\t\tarray.push(route);\n};\n\nmodule.exports = function() {\n\treturn new Router();\n};\n","// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function(root, factory) {\n  if (('function' === typeof define) && (define.amd != null)) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function() {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n  escapeForRegex = function(string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n  concatMap = function(array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n    return results;\n  };\n  stringConcatMap = function(array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n    while (++i < length) {\n      result += f(array[i]);\n    }\n    return result;\n  };\n  regexGroupCount = function(regex) {\n    return (new RegExp(regex.toString() + '|')).exec('').length - 1;\n  };\n  keysAndValuesToObject = function(keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n      if (value == null) {\n        continue;\n      }\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n    return object;\n  };\n  P = {};\n  P.Result = function(value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n  P.Tagged = function(tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n  P.tag = function(tag, parser) {\n    return function(input) {\n      var result, tagged;\n      result = parser(input);\n      if (result == null) {\n        return;\n      }\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n  P.regex = function(regex) {\n    return function(input) {\n      var matches, result;\n      matches = regex.exec(input);\n      if (matches == null) {\n        return;\n      }\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n  P.sequence = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n        if (result == null) {\n          return;\n        }\n        values.push(result.value);\n        rest = result.rest;\n      }\n      return new P.Result(values, rest);\n    };\n  };\n  P.pick = function() {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function(input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n      if (result == null) {\n        return;\n      }\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n  P.string = function(string) {\n    var length;\n    length = string.length;\n    return function(input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n  P.lazy = function(fn) {\n    var cached;\n    cached = null;\n    return function(input) {\n      if (cached == null) {\n        cached = fn();\n      }\n      return cached(input);\n    };\n  };\n  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n        if (endResult != null) {\n          break;\n        }\n      }\n      parserResult = parser(rest);\n      if (parserResult == null) {\n        break;\n      }\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n      rest = parserResult.rest;\n    }\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n    return new P.Result(results, rest);\n  };\n  P.many1 = function(parser) {\n    return function(input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n  P.concatMany1Till = function(parser, end) {\n    return function(input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n  P.firstChoice = function() {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function(input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n  newParser = function(options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function() {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function() {\n      return U.token;\n    }));\n    return U;\n  };\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n      case 'static':\n        return escapeForRegex(astNode.value);\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n  astNodeToRegexString = function(astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n  astNodeToNames = function(astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n      case 'named':\n        return [astNode.value];\n      case 'static':\n        return [];\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n  getParam = function(params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n    value = params[key];\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n    result = Array.isArray(value) ? value[index] : value;\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n    return result;\n  };\n  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {\n    var i, length;\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n      case 'static':\n        return false;\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n  stringify = function(astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function(node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n      case 'static':\n        return astNode.value;\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n    }\n  };\n  UrlPattern = function(arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n    this.isRegex = arg1 instanceof RegExp;\n    if (!(('string' === typeof arg1) || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n    if (this.isRegex) {\n      this.regex = arg1;\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n        groupCount = regexGroupCount(this.regex);\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n        this.names = arg2;\n      }\n      return;\n    }\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n  UrlPattern.prototype.match = function(url) {\n    var groups, match;\n    match = this.regex.exec(url);\n    if (match == null) {\n      return null;\n    }\n    groups = match.slice(1);\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n  UrlPattern.prototype.stringify = function(params) {\n    if (params == null) {\n      params = {};\n    }\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n    return stringify(this.ast, params, {});\n  };\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});\n","var AgnosticRouter = require('agnostic-router');\nvar Utils = require('./Utils');\nmodule.exports = {\n\t_sanitizeArgumentConfig: function(argumentConfigDirty) {\n\t\tvar argumentConfigDefault = {level: 0};\n\t\tvar argumentConfigSanitized = Utils.objectMerge(argumentConfigDefault, argumentConfigDirty);\n\t\tif(typeof argumentConfigSanitized.source == 'undefined')\n\t\t\targumentConfigSanitized.source = [];\n\t\telse if(!Array.isArray(argumentConfigSanitized.source))\n\t\t\targumentConfigSanitized.source = [argumentConfigSanitized.source];\n\t\treturn argumentConfigSanitized;\n\t},\n\t// Generate an object with functions\n\ttoObject: function(apiConfig, callback) {\n\t\tvar self = this;\n\t\tvar object = {};\n\n\t\t// Get UrlPattern\n\t\tvar router = AgnosticRouter();\n\t\tvar UrlPattern = router.UrlPattern;\n\n\t\tUtils.objectForEach(apiConfig, function(functionConfig, functionName) {\n\t\t\tif(typeof functionConfig.pattern != 'string')\n\t\t\t\tthrow new Error('pattern_undefined');\n\n\t\t\tvar urlPattern = new UrlPattern(functionConfig.pattern);\n\t\t\tvar argumentsConfig = Array.isArray(functionConfig.arguments) ? functionConfig.arguments : [];\n\n\t\t\tobject[functionName] = function() {\n\t\t\t\t// Get callback (last argument)\n\t\t\t\tvar argumentsArray = Array.prototype.slice.call(arguments);\n\t\t\t\tif(argumentsArray.length > 0 && typeof argumentsArray[argumentsArray.length - 1] == 'function')\n\t\t\t\t\tvar functionCallback = argumentsArray.pop();\n\n\t\t\t\tvar parsedFunctionArguments = Utils.parseArgs(argumentsArray, argumentsConfig);\n\t\t\t\tvar requestArguments = {};\n\n\t\t\t\targumentsConfig.forEach(function(argumentConfig) {\n\t\t\t\t\tvar argumentConfigSanitized = self._sanitizeArgumentConfig(argumentConfig);\n\t\t\t\t\tUtils.objectSet(requestArguments, argumentConfigSanitized.source.concat([argumentConfigSanitized.name]), parsedFunctionArguments[argumentConfigSanitized.name]);\n\t\t\t\t});\n\n\t\t\t\tvar urlPath = urlPattern.stringify(passArguments.params);\n\t\t\t\tcallback(functionName, urlPath, requestArguments, functionCallback);\n\t\t\t};\n\t\t});\n\n\t\treturn object;\n\t},\n\ttoRouter: function(apiConfig, targetObject, router) {\n\t\tvar self = this;\n\t\tif(typeof router != 'object')\n\t\t\trouter = AgnosticRouter();\n\n\t\tUtils.objectForEach(apiConfig, function(functionConfig, functionName) {\n\t\t\tif(typeof functionConfig.pattern != 'string')\n\t\t\t\tthrow new Error('pattern_undefined');\n\n\t\t\trouter.use(functionConfig.pattern, function(request, respond, next) {\n\n\t\t\t\tvar parsedArgs = [];\n\t\t\t\tif(Array.isArray(functionConfig.arguments)) {\n\t\t\t\t\tfunctionConfig.arguments.forEach(function(argumentConfig) { // Loop over arguments of function\n\t\t\t\t\t\tvar argumentConfigSanitized = self._sanitizeArgumentConfig(argumentConfig);\n\t\t\t\t\t\tvar argumentRequestPath = argumentConfigSanitized.source.concat(argumentConfigSanitized.name);\n\t\t\t\t\t\tif(argumentConfigSanitized.level == 0 || Utils.objectIsset(request, argumentRequestPath)) // argument is required or exists\n\t\t\t\t\t\t\tparsedArgs.push(Utils.objectGet(request, argumentRequestPath)); // add the argument to the array to pass\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\ttargetObject[functionName].apply(targetObject, parsedArgs.concat([respond])); // Add the callback at the end\n\t\t\t});\n\t\t});\n\n\t\treturn router;\n\t}\n};","// Utils module 1.0.11 MINI\nvar Utils = {};\n\nUtils.objectMerge = function() {\n\tvar merged = {};\n\tthis.objectForEach(arguments, function(argument) {\n\t\tfor (var attrname in argument) {\n\t\t\tif(argument.hasOwnProperty(attrname))\n\t\t\t\tmerged[attrname] = argument[attrname];\n\t\t}\n\t});\n\treturn merged;\n};\n\n\nUtils.objectFilter = function(object, filter) {\n\t// filter object properties (children) using filter function\n\t// similar to array filter function\n\tvar result = {};\n\tthis.objectForEach(object, function(child, property, parent) {\n\t\tif(filter(child, property, parent))\n\t\t\tresult[property] = child;\n\t});\n\treturn result;\n};\n\nUtils.objectForEach = function(object, callback) {\n\t// run function on each property (child) of object\n\tvar property;\n\tfor(property in object) { // pull keys before looping through?\n\t\tif (object.hasOwnProperty(property))\n\t\t\tcallback(object[property], property, object);\n\t}\n};\n\nUtils.objectGet = function(object, keys) {\n\tvar self = this;\n\tif(keys.length == 0)\n\t\treturn object;\n\telse if(typeof object === \"object\") {\n\t\tif((typeof keys[0] === \"string\" || typeof keys[0] === \"number\") && object !== null && object.hasOwnProperty(keys[0]))\n\t\t\treturn this.objectGet(object[keys[0]], keys.slice(1));\n\t\telse if(keys[0] === null) { // get all\n\t\t\tif(Array.isArray(object)) {\n\t\t\t\tvar results = [];\n\t\t\t\tobject.forEach(function(child, key) {\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar results = {};\n\t\t\t\tthis.objectForEach(object, function(child, key) {\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t\telse if(keys[0] instanceof RegExp) { // match keys to regexp\n\t\t\tvar results = {};\n\t\t\tthis.objectForEach(object, function(child, key) {\n\t\t\t\tif(key.match(keys[0]))\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t});\n\t\t\treturn results;\n\t\t}\n\t\telse if(typeof keys[0] === \"function\") { // apply a filtering function\n\t\t\tif(object instanceof Array) {\n\t\t\t\tvar results = [];\n\t\t\t\tobject.forEach(function(value, index, parent) {\n\t\t\t\t\tif(keys[0](value, index, parent)) // filter function\n\t\t\t\t\t\tresults[index] = self.objectGet(value, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar results = {};\n\t\t\t\tthis.objectForEach(self.objectFilter(object, keys[0]), function(result, key) {\n\t\t\t\t\tresults[key] = self.objectGet(result, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t\telse if(keys[0] instanceof Array) { // all members with keys in array\n\t\t\tif(object instanceof Array) {\n\t\t\t\tvar results = [];\n\t\t\t\tkeys[0].forEach(function(value, index) {\n\t\t\t\t\tresults[index] = object[index];\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar results = {};\n\t\t\t\tthis.objectForEach(self.objectFilterProperties(object, keys[0]), function(child, key) {\n\t\t\t\t\tresults[key] = self.objectGet(child, keys.slice(1));\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t}\n\telse\n\t\treturn;\n};\n\nUtils.objectSet = function(object, keys, value) {\n\tif(keys.length == 1) {\n\t\tobject[keys[0]] = value;\n\t\treturn true;\n\t}\n\telse {\n\t\tif(typeof(object[keys[0]]) === \"undefined\")\n\t\t\tobject[keys[0]] = {}; // set empty object so we can descend into it\n\t\treturn this.objectSet(object[keys[0]], keys.slice(1), value);\n\t}\n};\n\nUtils.objectIsset = function(object, keys) {\n\tif(keys.length == 1)\n\t\treturn (typeof(object[keys[0]]) !== \"undefined\");\n\telse if(typeof(object[keys[0]]) === \"undefined\") // current level doesn't exist\n\t\treturn false;\n\telse\n\t\treturn this.objectIsset(object[keys[0]], keys.slice(1));\n};\n\nUtils.parseArgs = function(argsPassed, argsConfig) {\n\tvar matched = {};\n\n\tfunction toLevels(argsConfig, level) {\n\t\tif(typeof level !== 'number')\n\t\t\tlevel = 0;\n\n\t\tvar levelsArr = [];\n\n\t\targsConfig.forEach(function(argConfig) {\n\t\t\tif(Array.isArray(argConfig))\n\t\t\t\tlevelsArr = levelsArr.concat(toLevels(argConfig, level + 1));\n\t\t\telse {\n\t\t\t\targConfig.level = level;\n\t\t\t\tlevelsArr.push(argConfig);\n\t\t\t}\n\t\t});\n\n\t\treturn levelsArr;\n\t}\n\n\tfunction validArg(argConfig, arg) {\n\t\treturn typeof argConfig.validate != 'function' || argConfig.validate(arg)\n\t}\n\n\tfunction requiredLeftEnough(argsConfig, minIndex) {\n\t\tfor(var index = minIndex; index < argsConfig.length; index++) {\n\t\t\tif(typeof(argsConfig[index]) === 'undefined' || !argsConfig[index].required)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvar argConfigMin = 0;\n\n\tif(!Array.isArray(argsPassed))\n\t\targsPassed = Array.prototype.slice.call(argsPassed);\n\n\targsPassed.forEach(function(arg, index) {\n\t\tfor(var ctr = argConfigMin; ctr < argsConfig.length; ctr++) {\n\t\t\tif(argsConfig[ctr].required) {\n\t\t\t\tif(validArg(argsConfig[ctr], arg)) {\n\t\t\t\t\targsConfig[ctr].matched = true;\n\t\t\t\t\tmatched[argsConfig[ctr].name] = arg;\n\t\t\t\t\targConfigMin++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tthrow \"missing_required\";\n\t\t\t}\n\t\t\telse if((!argsConfig[ctr].required && (requiredLeftEnough(argsConfig, ctr) || (argsConfig[ctr].level > argsConfig[ctr - 1].level && argsConfig[ctr - 1].matched))) && validArg(argsConfig[ctr], arg)) {\n\t\t\t\targsConfig[ctr].matched = true;\n\t\t\t\tmatched[argsConfig[ctr].name] = arg;\n\t\t\t\targConfigMin++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\targsConfig[ctr].matched = false;\n\t\t\t\targConfigMin++;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Add default options, if set\n\targsConfig.forEach(function(argConfig) {\n\t\tif(typeof matched[argConfig.name] == 'undefined' && typeof argConfig.default != 'undefined')\n\t\t\tmatched[argConfig.name] = argConfig.default;\n\t});\n\n\treturn matched;\n};\n\nmodule.exports = Utils;"]}